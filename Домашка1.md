## Задача 1
https://hub.docker.com/repository/docker/dk054/custom-nginx/tags/1.0.0/sha256-73402190b0857ea96916f12d3caefd47f68b578ef32e7924a3696c88d11e84f7
## Задача 2
sudo docker run -d --name "Kalashnikov.D.A-custom-nginx-t2" -p 127.0.0.1:8080:80 custom-nginx:1.0.0
sudo docker rename Kalashnikov.D.A-custom-nginx-t2 custom-nginx-t2
## Задача 3
sudo docker attach custom-nginx-t2
- После Ctrl-C основной процесс PID 1 внутри контейнера получил сигнал SIGINT и завершился.
- В Docker контейнер считается живым пока запущен его основной процесс. Если этот процесс завершился, контейнер переходит в статус Exited.
- Поэтому при выполнении docker ps -a вы увидите контейнер со статусом Exited — это означает, что контейнер остановлен из‑за завершения его основного процесса (в данном случае — в результате Ctrl-C).
4. sudo docker start custom-nginx-t2
5.  docker exec -it custom-nginx-t2 /bin/bash
6. apt-get update
   apt-get install -y vim
7. vi /etc/nginx/conf.d/default.conf
8. nginx -s reload
   а затем внутри контейнера ```curl http://127.0.0.1:80 ; curl http://127.0.0.1:81```.
10. Проверьте вывод команд: ```ss -tlpn | grep 127.0.0.1:8080```
    ```docker port custom-nginx-t2```
    ```curl http://127.0.0.1:8080```.
    Кратко объясните суть возникшей проблемы.
    в конфиге nginx внутри контейнера listen 80 → listen 81, но проброс портов контейнера на хост (docker run -p HOST:CONTAINER) вероятно настроен так, чтобы ожидать nginx на порту 80 или на 8080 хоста.
    Если nginx слушает 81 внутри контейнера, а docker пробрасывает, например, host:8080 → container:80, то на хосте 8080 будет «мёртвый» порт (нет сервера), а внутри контейнера curl на 81 вернёт ответ.
    То есть несоответствие слушаемого порта внутри контейнера и смэппинга портов на хосте — причина недоступности сервиса на ожидаемом хост-порте.
11. *
sudo docker stop custom-nginx-t2
sudo docker run -p 8080:81 custom-nginx

sudo docker run -d --name custom-nginx-t2 -p 127.0.0.1:8080:81

sudo iptables -t nat -A PREROUTING -p tcp -d 127.0.0.1 --dport 8080 -j DNAT --to-destination 172.17.0.2:81
sudo iptables -t nat -A POSTROUTING -p tcp -d 172.17.0.2 --dport 81 -j MASQUERADE
sudo docker exec -it custom-nginx-t2 curl -I http://127.0.0.1:80

12. docker rm -f custom-nginx-t2

## Задача 4
1.

sudo docker pull centos:7
sudo docker pull debian:latest
docker ps
docker run -d --name centos1 -v "$(pwd)":/data centos:7 sleep infinity
docker run -d --name debian1 -v "$(pwd)":/data debian:latest sleep infinity
docker exec -it centos1 bash -lc 'echo "Пример centos1" > /data/file_from_centos.txt'
echo "Файл с хоста" > "$(pwd)/file_from_host.txt"
docker exec -it debian1 bash -lc 'ls -la /data && echo "--- содержимое file_from_centos.txt ---" && cat /data/file_from_centos.txt && echo "--- содержимое file_from_host.txt ---" && cat /data/file_from_host.txt'


## Задача 5
1. mkdir -p /tmp/netology/docker/task5
   vi /tmp/netology/docker/task5/compose.yaml
   vi /tmp/netology/docker/task5/docker-compose.yaml
- Docker Compose (команда docker compose) ищет файл с именем docker-compose.yml или docker-compose.yaml по умолчанию в текущей директории. Имя compose.yaml не входит в список стандартных имен.
2.
x-include:
- ./docker-compose.yaml
  docker-compose -f compose.yaml -f docker-compose.yaml up -d
3.
- создаю докерфайл для custom-nginx
  mkdir custom-nginx
  cat > custom-nginx/Dockerfile <<'EOF'
  FROM nginx:alpine
  RUN echo '<h1>Custom NGINX</h1>' > /usr/share/nginx/html/index.html
  EOF
- собираю образ с тегом custom-nginx:latest
  docker build -t custom-nginx:latest custom-nginx
- проврка что registry запущен
  curl -I http://localhost:5000/v2/ || true
- тег  образа для локального registry
  docker tag custom-nginx:latest localhost:5000/custom-nginx:latest
- пуш
  docker push localhost:5000/custom-nginx:latest
- проверка
  curl -s http://localhost:5000/v2/_catalog | jq .
  curl -s http://localhost:5000/v2/custom-nginx/tags/list | jq .

4.
скрин
5.
скрин
6.
скрин
7.
docker-compose up -d --remove-orphans

docker-compose down --remove-orphans